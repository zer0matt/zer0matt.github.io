<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BYOVD: A journey through weaponizable anti-rootkit drivers | zer0matt's blog</title>
  <meta name="description" content="Avast anti-rootkit driver.">
  <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg">
  <style>
    :root {
      --bg: #fafafa;
      --text: #222;
      --link: #0366d6;
      --link-hover: #023e8a;
      --heading: #111;
      --muted: #666;
      --border: #e5e5e5;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: Consolas, "Lucida Console", monospace;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
    }

    header {
      text-align: center;
      padding: 2.5rem 1rem 1rem;
    }

    header h1 {
      margin: 0;
      font-size: 2rem;
      color: var(--heading);
    }

    nav {
      margin-top: 1rem;
    }

    nav a {
      margin: 0 0.8rem;
      color: var(--link);
      text-decoration: none;
      font-weight: 500;
    }

    nav a:hover {
      color: var(--link-hover);
    }

    main {
      max-width: 800px;
      margin: 0 auto;
      padding: 3rem 1rem 4rem;
    }

    section {
      margin-bottom: 2rem;
    }

    section h2 {
      font-size: 1.5rem;
      color: var(--heading);
      margin-bottom: 0.5rem;
      border-bottom: 2px solid var(--border);
      padding-bottom: 0.3rem;
    }

    p {
      margin-bottom: 1rem;
    }

    a {
      color: var(--link);
      text-decoration: none;
    }

    a:hover {
      color: var(--link-hover);
      text-decoration: underline;
    }

    footer {
      text-align: center;
      border-top: 1px solid var(--border);
      color: var(--muted);
      padding: 2rem 1rem;
      font-size: 0.9rem;
    }

    .badge {
      display: inline-block;
      background: #e5e5e5;
      color: #111;
      font-weight: 500;
      padding: 0.2rem 0.5rem;
      border-radius: 0.4rem;
      margin-right: 0.5rem;
      font-size: 0.95rem;
    }

    /* Snippet code box */
    .pre-block {
      background: #f7f7f8;
      color: #111;
      padding: 1rem;
      border-radius: 6px;
      border: 1px solid #e6e6e6;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Helvetica Neue", monospace;
      font-size: 0.92rem;
      line-height: 1.45;
      white-space: pre;
      overflow: auto;      /* scroll both horizontally and vertically */
      max-height: 60vh;    /* vertical scroll when content is tall */
      word-break: normal;
    }

    .pre-block:hover {
      box-shadow: 0 6px 24px rgba(0,0,0,0.06);
    }
  </style>
</head>
<body>
  <header>
    <h1>BYOVD: A journey through weaponizable anti-rootkit drivers</h1>
    <nav>
      <a href="https://zer0matt.github.io/">Home</a>
      <a href="https://zer0matt.github.io/about/">About</a>
      <a href="https://zer0matt.github.io/vulnerability/">Vulnerabilities</a>
      <a href="https://github.com/zer0matt" target="_blank">GitHub</a>
      <a href="https://www.linkedin.com/in/rosario-matteo-grammatico/" target="_blank">Linkedin</a>
    </nav>
  </header>

  <main>
    <section>
      <h2>Overview</h2>
	  
	  <p>Approaching kernel exploitation can often lead to a serious headache. Modern operating systems implement a wide range of protection mechanisms designed to safeguard kernel structures (PatchGuard), making low-level attacks increasingly difficult.
	  A common starting point is looking into driver vulnerabilities. Drivers operate in ring-0 and whenever they're flawed, they can provide a pathway into kernel space, potentially resulting in full operating system compromise.</p>
	  <p>Once a driver vulnerability is abused, you effectively step into “kernel-land” where the system grants a high degree of control. In theory, this could involve actions such as bypassing signature requirements, tampering with protected processes, or interfering with security components such as disabling AntiVirus/EDR.
	  If you’re new to kernel exploitation and want to understand how driver exploitation works, a great learning resource is the HackSys Extreme Vulnerable Driver project: <a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver" target="_blank">https://github.com/hacksysteam/HackSysExtremeVulnerableDriver</a>.</p>
	  <p>Before diving deeper, it’s important to understand how drivers receive input. Drivers expose specific IOCTL (Input/Output Control) codes, which define the operations that user-mode applications can request. These IOCTLs form the communication channel between user-land and kernel-land.
	  To make this communication possible, the driver must also expose a symbolic link, typically located under \Device or \DosDevices. Tools like WinObj allow you to inspect these symbolic links quickly and visually.</p>
	</section>

    <section>
      <h2>Introduction</h2>
      <p>I’ve always found it fascinating how anti-rootkits can act as a double-edged sword.
	  While granting them high privileges makes sense given the stealthy nature of rootkits, this level of access can also be risky and, in some cases, even counterproductive or dangerous for the end user.
	  A well-known example of how an anti-rootkit component can be turned into a weaponized tool is aswArPot.sys, which is capable of terminating arbitrary processes.</p>
	  <p>For this article, I wanted to offer something that could be analyzed from scratch, so I picked up the awsArPot.sys driver from Avast AV as a subject of investigation.
	  I will walk through the work step by step to provide a clear overview, even for readers who are approaching this area for the first time.
	  Please note: I am not an expert in kernel exploitation. This article reflects my own research and my attempts to learn more about the topic, so forgive me if some details are not perfectly accurate.</p>
    </section>
	<section>
	  <h2>Target</h2>
	  <p>The target is to abuse the ZwTerminateProcess syscall in order to kill any process arbitrarily by passing the PID of the target process as a parameter.</p>
	</section>
	<section>
	  <h2>Technical analysis</h2>
	  <p>First things first: when evaluating whether a driver can be repurposed for malicious behavior, one typically checks whether it references functions such as ZwOpenProcess/NtOpenProcess and ZwTerminateProcess/NtTerminateProcess.
	  Their presence can indicate that the driver includes logic for interacting with or terminating processes.</p>
	  <p>Within the Avast AV driver set, aswArPot.sys appears to be the component responsible for anti-rootkit functionality.</p>
	  <p>After identifying the driver of interest, the next step is to analyze it with a reverse-engineering tool such as IDA or Ghidra.</p>
	  <p>Kernel drivers include an entry point known as DriverEntry. Using IDA, it's possible to decompile this entry point and view its pseudocode, which resembles C/C++ and provides a clearer understanding of the logic executed during the driver's initialization.</p>
	  <p>Starting from DriverEntry, we can follow the call chain through the program until we reach the routine where the driver interacts with process-management functions such as ZwTerminateProcess.</p>
	  <p>
	  <img src="1.png" alt="aswarpotdriver1" style="display:block; margin:0 auto; max-width:100%;">
	  </p>
	  <p>So the function that calls ZwTerminateProcess is <b>sub_1400282E0</b>, we'll take note on that.</p>
	  <p>IDA offers us a cool functionality that allows us to see in a graph view where functions are being called from.</p>
	  <img src="2.png" alt="aswarpotdriver2" style="display:block; margin:0 auto; max-width:100%;">
	  <p>Nevertheless, we have found the ioctl dispatcher located into the <b>sub_140023238</b> function, as showed in the pic below.</p>
	  <img src="3.png" alt="aswarpotdriver3" style="display:block; margin:0 auto; max-width:100%;">
	  <p>Great! Now we know the ioctl that triggers this behaviour. It's time to find the symbolic link exposed!</p>
	  <p>I have to admit it, I was stucked for a couple of days because I couldn't find an exposed symlink.</p>
	  <p>After struggling a little bit deeper inside the reversed pseudocode (check IoCreateSymlink function on the imports table) I found a potential candidate: <b>aswSP_Avar</b>.
	  <img src="4.png" alt="aswarpotdriver4" style="display:block; margin:0 auto; max-width:100%;">
	  </p>
	  <p>
	  That was a great news after I spent the whole weekend reversing this driver.
	  So I try to run a little C++ program to open a handle to such device and...Error 50: ERROR_NOT_SUPPORTED.
	  </p>
	  <p>Mmm...that's strange. It should at least let me open a handle but something is not right.
	  Searching on the web, it appears on this <a href="https://www.trellix.com/blogs/research/when-guardians-become-predators-how-malware-corrupts-the-protectors/" target="_blank">article</a> (that I should have checked before) that I was right about the symlink and IOCTL but seems that is has already been discovered by Trellix researchers and patched by Avast.
	  <p>
	</section>
	
	<section>
	  <h2>Conclusion</h2>
	  <p>
	  That ends our journey, the target of this article was to illustrate how I did find the "vulnerable" IOCTL and how we could have exploited it in order to build our personal AV Killer (or any arbitrary process killer).
	  </p>
	</section>
	  
	<section>
      <h2>References & Resources</h2>
      <ul>
        <li><a href="https://www.trellix.com/blogs/research/when-guardians-become-predators-how-malware-corrupts-the-protectors/" target="_blank">Trellix research: when guardians become predators how malware corrupts the protectors</a></li>
      </ul>
    </section>
  </main>

  <footer>
    © 2025 zer0matt. All rights reserved.
  </footer>

</body>
</html>